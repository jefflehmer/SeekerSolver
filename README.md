# SeekerSolver
This project is simply the C# implementation of the layout of a popular game on a site that does not need to be mentioned.  The purpose of this project is not to make it easy for someone to cheat in the game.  I doubt that would be possible without significant additions of AI.  No, it is only meant as the setup of the game so that anyone who wants to test their own algorithms for finding the optimal solution path in a comparable scenario will be able to focus on the algorithm since the setup work has already been done.

I was a C++ programmer for many years (more recently C#) and have spent the bulk of my programming career in scientific software.  I have always enjoyed finding different ways to solve difficult problems.  I really enjoyed the Traveling Salesman Problem and NP Complete(ness) back in college.  Don't get me started with the complexities (and excitement) of solving a chess move!  That translated well into my scientific programming career where I was often faced with networked objects and a problem.  To this day I cannot play a game without thinking about the best way to programmatically search for optimal solutions.  I prefer to write my own video games than play someone else's.

The idea of the game is to find the longest chain of logically connected nodes out of a simple board.  For example, if you start at a node with the value of '2' you can move to a node with the value of '1' or '3'.  The game starts with the requirement to add or subtract by 1 but increases to 2s then 3s later on.  The numbers on the board increase in quantity from 1 to 3, then 1 to 4, then 1 to 5.  Ditto for multiples of 2s and 3s.  There are nine columns of individual cells but each column is staggered half a cell from the previous and next columns.  This is sort of like being caught in an elevator half-way between two floors.  If you can open the door you can exit through the upper floor or the lower one.  This allows any cell in the middle of the board to move in any of six different directions (up, upper-right, lower-right, down, lower-left, upper-left).  Of course, cells on the outside of the board will only be able to travel back into the middle of the board.  Did I mention the staggered columns alternate between six and seven cells (6,7,6,7,6,7,6,7,6)!?

Will I continue to add to this setup as I go along?  I hope so.  I eventually want to add different weights to each cell and add calculations for optimal path based on these values.  For now, here's the board.  I'll try to add different "enumerators" that traverse the structure in different ways first.  For example, the first one will go through every cell in a column before moving on to the cells in the next column.  The following enumerator will travel the graph of connected cells in (optionally) depth-first or breadth-first options.

You get the idea! ;o)

Wish me luck!  Of course, I welcome input from any other sick algorithm dogs like myself! (woof)

Marcus